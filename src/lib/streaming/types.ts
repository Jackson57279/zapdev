/**
 * Conversation and State Types for AI Code Generation
 * 
 * Based on open-lovable's conversation tracking and state management patterns.
 */

// ============================================================================
// Conversation State Types
// ============================================================================

/**
 * A single message in the conversation history.
 */
export interface ConversationMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
  metadata?: {
    editedFiles?: string[];       // Files edited in this interaction
    addedPackages?: string[];     // Packages added in this interaction
    editType?: string;            // Type of edit performed
    sandboxId?: string;           // Sandbox ID at time of message
    projectId?: string;           // Associated project ID
  };
}

/**
 * Record of an edit operation performed by the AI.
 */
export interface ConversationEdit {
  timestamp: number;
  userRequest: string;
  editType: EditType;
  targetFiles: string[];
  confidence: number;             // 0-1 confidence score
  outcome: 'success' | 'partial' | 'failed';
  errorMessage?: string;
}

/**
 * Types of edit operations the AI can perform.
 */
export type EditType = 
  | 'UPDATE_COMPONENT'
  | 'ADD_FEATURE'
  | 'FIX_BUG'
  | 'REFACTOR'
  | 'STYLING'
  | 'DELETE'
  | 'CREATE_COMPONENT'
  | 'UNKNOWN';

/**
 * Full conversation context including history and evolution.
 */
export interface ConversationContext {
  messages: ConversationMessage[];
  edits: ConversationEdit[];
  currentTopic?: string;          // Current focus area (e.g., "header styling")
  projectEvolution: {
    initialState?: string;        // Description of initial project state
    majorChanges: Array<{
      timestamp: number;
      description: string;
      filesAffected: string[];
    }>;
  };
  userPreferences: {
    editStyle?: 'targeted' | 'comprehensive';
    commonRequests?: string[];
    packagePreferences?: string[];
  };
}

/**
 * Complete conversation state for a session.
 */
export interface ConversationState {
  conversationId: string;
  projectId: string;
  startedAt: number;
  lastUpdated: number;
  context: ConversationContext;
}

// ============================================================================
// File Manifest Types
// ============================================================================

/**
 * Information about a single file in the project.
 */
export interface FileInfo {
  path: string;
  type: 'jsx' | 'tsx' | 'js' | 'ts' | 'css' | 'json' | 'html' | 'md' | 'other';
  size: number;
  lastModified?: number;
  isDirectory?: boolean;
  description?: string;           // AI-generated description
}

/**
 * Complete file manifest for the project.
 */
export interface FileManifest {
  files: Record<string, FileInfo>;
  structure: string;              // Tree representation
  totalFiles: number;
  totalSize: number;
  lastUpdated: number;
}

/**
 * Cached file content with metadata.
 */
export interface CachedFile {
  content: string;
  lastModified: number;
  hash?: string;
}

/**
 * File cache for fast lookups.
 */
export interface FileCache {
  files: Record<string, CachedFile>;
  manifest?: FileManifest;
  lastSync: number;
  sandboxId: string;
}

// ============================================================================
// Edit Intent Types
// ============================================================================

/**
 * Search plan generated by AI for finding files to edit.
 */
export interface SearchPlan {
  searchTerms: string[];
  editType: EditType;
  reasoning: string;
  confidence: number;
  suggestedFiles?: string[];
}

/**
 * Result of searching for code in the codebase.
 */
export interface SearchResult {
  filePath: string;
  lineNumber: number;
  matchedText: string;
  context: string;                // Surrounding code
  confidence: number;
  reason: string;
}

/**
 * Context for an edit operation.
 */
export interface EditContext {
  primaryFiles: string[];         // Files to edit (full content provided)
  contextFiles: string[];         // Files for reference (structure only)
  systemPrompt: string;           // Enhanced system prompt with context
  editIntent: {
    type: EditType;
    description: string;
    targetFiles: string[];
    confidence: number;
    searchTerms?: string[];
    suggestedContext?: string[];
  };
}

// ============================================================================
// Sandbox State Types
// ============================================================================

/**
 * Information about an active sandbox.
 */
export interface SandboxInfo {
  sandboxId: string;
  url: string;
  provider: 'e2b' | 'vercel' | 'local';
  createdAt: number;
  lastActivity: number;
  framework: string;
}

/**
 * Result of running a command in the sandbox.
 */
export interface CommandResult {
  stdout: string;
  stderr: string;
  exitCode: number;
  success: boolean;
}

/**
 * Complete sandbox state.
 */
export interface SandboxState {
  info: SandboxInfo | null;
  fileCache?: FileCache;
  isAlive: boolean;
  lastCommand?: CommandResult;
}

// ============================================================================
// Generation Request/Response Types
// ============================================================================

/**
 * Request body for code generation.
 */
export interface GenerateCodeRequest {
  prompt: string;
  model?: string;
  isEdit?: boolean;
  context?: {
    sandboxId?: string;
    projectId?: string;
    currentFiles?: Record<string, string>;
    structure?: string;
    conversationContext?: {
      scrapedWebsites?: Array<{ url: string; content: unknown; timestamp: Date }>;
      currentProject?: string;
    };
  };
}

/**
 * Request body for applying generated code.
 */
export interface ApplyCodeRequest {
  response: string;               // Raw AI response to parse
  isEdit?: boolean;
  packages?: string[];            // Pre-detected packages
  sandboxId?: string;
}

/**
 * Parsed result from AI response.
 */
export interface ParsedAIResponse {
  files: Array<{ path: string; content: string }>;
  packages: string[];
  commands: string[];
  structure: string | null;
  explanation: string;
  template: string;
}

// ============================================================================
// AI Provider Types
// ============================================================================

/**
 * Configuration for an AI model.
 */
export interface ModelConfig {
  name: string;
  provider: 'anthropic' | 'openai' | 'google' | 'groq' | 'zhipu' | 'qwen';
  description: string;
  temperature?: number;
  maxTokens?: number;
  frequencyPenalty?: number;
  skipValidation?: boolean;
}

/**
 * Supported model identifiers.
 */
export type ModelId = 
  | 'auto'
  | 'anthropic/claude-sonnet-4'
  | 'anthropic/claude-haiku-4.5'
  | 'openai/gpt-5'
  | 'openai/gpt-4-turbo'
  | 'google/gemini-3-pro-preview'
  | 'google/gemini-3-flash'
  | 'groq/llama-3.3-70b'
  | 'moonshotai/kimi-k2-instruct-0905';

// ============================================================================
// App Configuration Types
// ============================================================================

/**
 * Complete application configuration.
 */
export interface AppConfig {
  ai: {
    defaultModel: ModelId;
    availableModels: ModelId[];
    modelDisplayNames: Record<ModelId, string>;
    defaultTemperature: number;
    maxTokens: number;
  };
  sandbox: {
    e2b: {
      timeoutMinutes: number;
      vitePort: number;
      workingDirectory: string;
    };
    vercel?: {
      timeoutMinutes: number;
      devPort: number;
    };
  };
  codeApplication: {
    enableTruncationRecovery: boolean;
    defaultRefreshDelay: number;
    packageInstallRefreshDelay: number;
    maxTruncationRecoveryAttempts: number;
  };
  conversation: {
    maxMessages: number;
    maxEdits: number;
    maxMajorChanges: number;
    contextWindowSize: number;
  };
}

// ============================================================================
// User Preferences Analysis Types
// ============================================================================

/**
 * Analyzed user preferences from conversation history.
 */
export interface UserPreferencesAnalysis {
  commonPatterns: string[];
  preferredEditStyle: 'targeted' | 'comprehensive';
  frequentComponents: string[];
  packagePreferences: string[];
}

/**
 * Analyze user preferences from conversation messages.
 */
export function analyzeUserPreferences(
  messages: ConversationMessage[]
): UserPreferencesAnalysis {
  const userMessages = messages.filter(m => m.role === 'user');
  const patterns: string[] = [];
  
  let targetedEditCount = 0;
  let comprehensiveEditCount = 0;
  const componentMentions: Record<string, number> = {};
  
  userMessages.forEach(msg => {
    const content = msg.content.toLowerCase();
    
    // Check for targeted edit patterns
    if (content.match(/\b(update|change|fix|modify|edit|remove|delete)\s+(\w+\s+)?(\w+)\b/)) {
      targetedEditCount++;
    }
    
    // Check for comprehensive edit patterns
    if (content.match(/\b(rebuild|recreate|redesign|overhaul|refactor)\b/)) {
      comprehensiveEditCount++;
    }
    
    // Extract common request patterns
    if (content.includes('hero')) {
      patterns.push('hero section edits');
      componentMentions['hero'] = (componentMentions['hero'] || 0) + 1;
    }
    if (content.includes('header')) {
      patterns.push('header modifications');
      componentMentions['header'] = (componentMentions['header'] || 0) + 1;
    }
    if (content.includes('color') || content.includes('style')) {
      patterns.push('styling changes');
    }
    if (content.includes('button')) {
      patterns.push('button updates');
      componentMentions['button'] = (componentMentions['button'] || 0) + 1;
    }
    if (content.includes('animation')) {
      patterns.push('animation requests');
    }
    if (content.includes('footer')) {
      componentMentions['footer'] = (componentMentions['footer'] || 0) + 1;
    }
    if (content.includes('nav')) {
      componentMentions['nav'] = (componentMentions['nav'] || 0) + 1;
    }
  });
  
  // Get top 3 unique patterns
  const uniquePatterns = [...new Set(patterns)].slice(0, 3);
  
  // Sort components by frequency
  const frequentComponents = Object.entries(componentMentions)
    .sort(([, a], [, b]) => b - a)
    .slice(0, 5)
    .map(([name]) => name);
  
  // Extract package preferences from metadata
  const packagePreferences: string[] = [];
  messages.forEach(msg => {
    if (msg.metadata?.addedPackages) {
      packagePreferences.push(...msg.metadata.addedPackages);
    }
  });
  
  return {
    commonPatterns: uniquePatterns,
    preferredEditStyle: targetedEditCount > comprehensiveEditCount ? 'targeted' : 'comprehensive',
    frequentComponents,
    packagePreferences: [...new Set(packagePreferences)],
  };
}
